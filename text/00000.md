# Введение в Git и VCS

Итак, начинаем мы как ни странно с git и github. 
Почему эти инструменты?
Все просто! Неотъемлемая часть разработки - 
это работа в команде.

Кодовая база большинства крупных компаний исчисляется миллионами строк кода. Например: [около **2 миллиардов** строк кода содержат проекты Google](https://medium.freecodecamp.org/the-biggest-codebases-in-history-a128bb3eea73).

![alt text](https://user-images.githubusercontent.com/4215285/50921153-5f4bee00-1458-11e9-9ca5-8572c87157e9.jpeg)

Резонный вопрос: как поддерживать данный код? Как вносить изменения, если параллельно с проектами работают **десятки разработчиков**? Каким образом отслеживать изменения кода? Если кто-то накосячил, как узнать кто это был?

## Системы контроля версий

### Локальные 

Одним из решений являются системы контроля версий. Системы контроля версий - это хранилище версий файлов.

![alt text](https://user-images.githubusercontent.com/4215285/51089802-676f9a80-1784-11e9-9ac6-e658fd1d2972.jpeg)

Первыми системами контроля версий были **локальные**, с помощью которых можно было просматривать историю изменения файлов - патчи (больше информации о типах СКВ вы можете узнать [тут](https://git-scm.com/book/ru/v2/%D0%92%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-%D0%9E-%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B5-%D0%BA%D0%BE%D0%BD%D1%82%D1%80%D0%BE%D0%BB%D1%8F-%D0%B2%D0%B5%D1%80%D1%81%D0%B8%D0%B9)).

> Например: **Файл 1** менялся *28.11*, *11.12*, *15.12* и мы можем откатить его к **V1** (см. рисунок выше).

Но **локальные** СКВ не подходят для командной работы, так как все файлы находятся на одном компьютере.

### Централизованные 

Впоследствии были созданы **централизованные** системы контроля версий, при которых для каждого файла хранится информация о его предыдущих версиях на центральном сервере.

![alt text](https://user-images.githubusercontent.com/4215285/51078564-07b3b980-16c8-11e9-8964-fd23eccc8339.jpeg)

Отлично. Мы решили проблему взаимодействия разработчиков. 

Но возникает следующая проблема - отказ центрального сервера (допустим, что злой разработчик повредил базу данных) приведет к отсутствию доступа у разработчиков к СКВ. Никто не сможет отправить свои изменения на сервер (см. рисунок выше).

### Децентрализованные 

И тут на сцену выходят **децентрализованные** системы контроля версий, к которым и относится **Git**.

![alt text](https://user-images.githubusercontent.com/4215285/50921159-607d1b00-1458-11e9-97ab-cdd7fb467dfd.jpeg)

При использовании децентрализованных СКВ разработчики полностью копируют всю информацию о версиях файлов себе на компьютер. И, если откажет центральный сервер, любой разработчик может его восстановить. 

## Git

Рассмотрим **Git** - мастодонт систем контроля версий.

![alt text](https://user-images.githubusercontent.com/4215285/51089803-676f9a80-1784-11e9-9eb1-597cdc19f30f.jpeg)

Как мы говорили, большинство СКВ в каждой версии хранят изменения файлов относительно первой версии. **Git** же хранит состояние всех файлов в определенный момент времени (см. рисунок выше). Такой снимок называется **коммит**.

> Например: **Файл 1** менялся *28.11*, *11.12*, *15.12* и каждый раз сохранялись не только его изменения относительно первой версии, а состояние файловой системы в момент выполнения коммита.

Если с предыдущего снимка файл не изменился, то для увеличения эффективности Git не копирует этот файл, а делает на него ссылку.

Обращение к снимкам идет с помощью хеш-суммы, которая вычисляется на основании файлов и структуры каталогов. По этой причине, если кто-то изменит файл в снимке, вы сразу это поймете.

> Пример хэш-суммы: 
> **44b8ab20c3527f6fc9b155f6cbff1e96c2de7067**

Большинство операций Git выполняются локально и затем выполненные изменения синхронизируются с удаленным сервером. 
По итогу вы можете работать с базой git без интернета и доступа к центральному серверу.

За основу материала был взят [git-scm](https://git-scm.com/book/ru/v2/).
