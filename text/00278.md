## Исключения

### Введение

> Начав заниматься программированием, мы, к своему удивлению, обнаружили, что не так уж просто заставить программы делать задуманное. Я могу точно вспомнить момент, когда я понял, что большая часть моей жизни с этих пор будет посвящена поиску ошибок в собственных программах.
>
> (c) Морис Уилкс.

Предположим, вам понадобилась программа, считывающая содержимое файла.
В целом, здесь нет ничего сложного и код, выполняющий поставленную задачу, мог бы выглядеть как-то так:

```java
    public List<String> readAll(String path) {
        BufferedReader br = new BufferedReader(new FileReader(path));
        String line;
        List<String> lines = new ArrayList<>();
        while ((line = br.readLine()) != null) {
            lines.add(line);
        }

        return lines;
    }
```

И это был бы вполне рабочий вариант, если бы не одно но: мы живем не в идеальном мире. Код, приведенный выше, расчитан на то, что все не просто работает идеально, а еще и на то, что путь до файла указан верный, файл можно прочитать и еще огромное количество предположений.

Однако, как показывает практика, мир не идеален, а нас повсюду преследуют ошибки и проблемы. Кто-то может указать путь до несуществующего файла, во время чтения может произойти ошибка, например, файл поврежден или удален в процессе чтения и т.д.

Игнорирование подобных ситуаций недопустимо, так как это путь к нестабильно и непредсказуемо работающему коду.
Значит, на такие ситуации надо реагировать.

Самая простая реакция - это возвращать некоторый код ошибки, некоторое число.
Например, 0 - это код удачного завершения приложения.
Мы получаем код возврата и уже на него реагируем.

Подобный ход имеет право на жизнь, однако, он крайне неудобен в повседневной разработке с ее тысячами возможных ошибок и проблемных ситуаций.

Во-первых, он слишком немногословен, так как необходимо помнить что означает каждый код-возврата, либо постоянно сверятся с таблицей расшифровки, где они описаны.

Во-вторых, такой подход предоставляет не совсем удобный способ обработки возникших ошибок. Более того, нередки ситуации, когда в месте возникновения ошибки непонятно как реагировать на возникшую проблему. В таком случае было бы удобнее делегировать обработку ошибки вызывающему коду, до места, где будет понятно как реагировать на ошибку.

В-третьих, и это, на мой взгляд, самое главное - это небезопасно, так как подобный способ можно легко проигнорировать или просто не заметить.

> Lots of newbie's coming in from the C world complain about exceptions and the fact that they have to put exception handling all over the place—they want to just write their code. But that's stupid: most C code never checks return codes and so it tends to be very fragile. If you want to build something really robust, you need to pay attention to things that can go wrong, and most folks don't in the C world because it's just too damn hard.
One of the design principles behind Java is that I don't care much about how long it takes to slap together something that kind of works. The real measure is how long it takes to write something solid.
>
> In Java you can ignore exceptions, but you have to willfully do it. You can't accidentally say, "I don't care." You have to explicitly say, "I don't care."
>
> (c) James Gosling.

Поэтому, в `Java` используется другой механизм работы с такими ситуациями: исключения.

Что такое исключение? В некотором смысле можно сказать, что исключение - это некоторое сообщение, уведомляющее о проблеме, незапланированном поведении.
В нашем примере с чтением содержимого файла, источником такого сообщения может являться `BufferedReader` или `FileReader`. Сообщению необходим получатель/обработчик, чтобы перехватить его и что-то сделать, отреагировать.

Крайне важно понимать, что генерация исключения ломает поток выполнения программы, так как либо это сообщение будет перехвачено и обработано каким-то зарегистрированным получателем, либо программа завершится.
Представьте, что по дороге едет грузовик. То, что грузовик едет и есть поток выполнения программы. Вдруг водитель видит, что впереди разрушенный мост - исключение, ошибка. Теперь он либо поедет по объездной дороге, т.е перехватит и отреагирует на исключение, либо остановится и поездка будет завершена.

![Объездная](../images/exception/exception_ob.png)

Сообщения бывают разного вида, а значит и получателей может быть несколько - на каждый отдельный вид сообщения может быть своя реакция, свой обработчик.
Такое сообщение может хранить данные об ошибке или нестандартной ситуации: причину, сообщение-описание и т.д.
Исходя из описания можно сказать, что исключение - это объект некоторого, специально для этого предназначенного класса. Так как проблемы и ошибки бывают разного рода, их можно классифицировать и логически разделить, значит и классы исключений можно выстроить в некоторую иерархию.

Как генерировать исключения и регистрировать обработчики мы рассмотрим позднее, а пока давайте взглянем на иерархию этих классов.

### Иерархия исключений

Ниже приведена иерархия исключений:

![Exception Hierarchy](../images/exception/exceptions.png)

*Картинка большая, чтобы лучше запоминалась.*

Для начала разберем загадачные подписи `checked` и `unchecked` на рисунке.

#### Проверяемые и непроверяемые

Все исключения в `Java` делятся на два типа: проверяемые(`checked`) и непроверяемые исключения(`unchecked`).

Как мы видим по схеме, `java.lang.Throwable` и `java.lang.Exception` относятся к проверяемым исключениям, в то время как `java.lang.RuntimeException` и `java.lang.Error` - это непроверяемые исключения.

> Такое разделение существует только в `Java`, в других языках программирования, таких  как `Scala`, `Groovy` или `Python`, все исключения непроверяемые.

В чем же смысл разделения на проверяемые и непроверяемые исключения?

Так как `Java` - это компилируемый язык, то помимо, `runtime`(непосредственно работы вашего кода), существует еще и `compile time`(то, что происходит во время компиляции).

Так вот проверяемые исключения - это исключения, на которые разработчик **обязан** отреагировать, т.е написать какие-то обработчики, их наличие проверяется на этапе компиляции.
Непроверяемые исключения - это исключения времени выполнения, возникающие прямо во время выполнения приложения. Разработчик может, но **не обязан** на них реагировать.

Почему в `Java` ввели подобное разграничение? Проверяемые исключения в `Java` используются тогда, когда разработчик никак не может предотвратить их возникновение. Причину возникновения `java.lang.RuntimeException` можно проверить и устранить заранее, например, проверить ссылку на `null` перед вызовом метода, на объекте по ссылке. А вот с причинами проверяемых исключений так сделать не получится, так как ошибка при чтении файла может возникнуть непосредственно в момент чтения, потому что другая программа его удалила. Соответственно, при чтении файла требуется обрабатывать `java.lang.IOException`, который является потомком `java.lang.Exception`.

Представьте, что вы едете по дороге, так вот предупредительные знаки - это проверяемые исключения. Например, знак "Осторожно, дети!" говорит о том, что рядом школа и дорогу может перебежать ребенок. Вы обязаны отреагировать на это, не обязательно ребенок перебежит вам дорогу, но вы не можете это проконтролировать, и в этом месте это наиболее вероятно.

Теперь рассмотрим непосредственно иерархию исключений.

#### Иерархия

Итак, корнем иерархии является `java.lang.Throwable`, у которого два наследника: `java.lang.Exception` и `java.lang.Error`.
В свою очередь `java.lang.Exception` является родительским классом для `java.lang.RuntimeException`.

> Занятно, что класс `java.lang.Throwable` назван так, как обычно называют интерфейсы, что иногда вводит в заблуждение новичков. Однако помните, что это класс!

Так как в `Java` все классы являются наследниками `java.lang.Object`, то и исключения(будучи тоже классами) наследуют все стандартные методы, такие как `equals`, `hashCode`, `toString` и т.д.
Раз мы работаем с классами, то можно с помощью наследования создавать свои собственные иерархии исключений, добавляя в них какое-то поведение и состояние.
Чтобы создать свой собственный класс исключение необходимо отнаследоваться от одного из классов в иерархии исключений. При этом наследуется еще и тип исключения: проверяемое или непроверяемое.

Т.е все наследники `java.lang.Exception` будут проверяемыми исключениями, в то время как все наследники `java.lang.RuntimeException` будут непроверяемыми.

##### Классификация

Каждый тип исключения охватывает свою область ошибок.

* `java.lang.Exception`

    Это ситуации, которые не подконтрольны разработчику, например, не получилось закрыть файловый дескриптор или отослать письмо.
    Это проверяемые исключения, мы **обязаны** на такие исключения реагировать. Степень серьезности таких исключений варьируется от простой до умеренной.

    Пример: `java.lang.IOException`.

* `java.lang.RuntimeException`

    Это ситуации, когда основной причиной ошибки является сам разработчик, например, происходит обращение к `null` ссылке, деление на ноль, выход за границы массива и т.д.
    Это непроверяемые исключения, реагировать на них или нет решает разработчик. И такие ошибки **можно** предотвратить.

    Пример: `java.lang.NullPointerException`.

* `java.lang.Error`

    Это критические ошибки, аварийные ситуации, после которых мы с трудом или вообще не в состоянии продолжить работу. Например, закончилась память, переполнился стек вызовов и т.д.

    Это непроверяемые исключения, реагировать на них или нет решает разработчик.
    Реагировать на подобные ошибки следует только в том случае, если разработчик точно знает как поступить в такой ситуации. Перехватывать такие ошибки не рекомендуется, так как обычно разработчик не знает как реагировать на подобного рода аварийные ситуации.

Основное отличие `java.lang.Exception` от `java.lang.RuntimeException` состоит в том, что причины `java.lang.RuntimeException` можно проверить и устранить заранее. Прежде чем обратиться по ссылке можно сделать проверку на `null`, тем самым избежав `java.lang.NullPointerException`. Прежде чем начать считывать содержимое текстового файла можно проверить: существует ли файл по указанному пути, хватает ли прав на чтение и т.д.

Теперь перейдем к вопросу: в чем же разница между `java.lang.Error` и `java.lang.Exception`?

##### Error и Exception

Все просто. Исключения `java.lang.Error` - это более серьезная ситуация, нежели `java.lang.Exception`.
Это серьезные проблемы в работе приложения, которые тяжело исправить, либо вообще неясно, можно ли это сделать.

Это не просто исключительная ситуация - это ситуация, в которой работоспособность всего приложения под угрозой! Например, исключение `java.lang.OutOfMemoryError`, сигнализирующее о том, что кончается память или `java.lang.StackOverflowError` – переполнение стека вызовов, которое можно встретить при бесконечной рекурсии.

Согласитесь, что если не получается преобразовать строку к числу, то это не та ситуация, когда все приложение должно завершаться. Это ситуация, после которой приложение **может продолжить** работать.
Да, это неприятно, что вы не смогли найти файл по указанному пути, но не настолько критично, как переполнение стека вызовов.

Т.е разница - в **логическом разделении**.

Поэтому, `java.lang.Error` используется только для критических ситуаций.

### Работа с исключениями

#### Обработка исключений

Корнем иерархии является класс `java.lang.Throwable`, т.е. "бросаемое".
А раз исключения бросаются, то для обработки мы будем ловить их!

В `Java` исключения ловят и обрабатывают с помощью конструкции `try/catch/finally`.

При заключении кода в один или несколько блоков `try` указывается потенциальная возможность выбрасывания исключения в этом месте, все операторы, которые могут сгенерировать исключение, помещаются в этом блоке.

В блоках `catch` перечисляются исключения, на которые решено реагировать. Тут определяются блоки кода, предназначенные для решения возникших проблем. Это и есть объявление тех самых получателей/обработчиков исключений.

Тот тип исключения, что указывается в `catch` блоке можно расценивать как фильтр, который перехватывает все исключения того типа, что вы указали и всех его потомков, расположенных ниже по иерархии.

Представьте себе просеивание муки. Это процесс целью которого является удаление посторонних частиц, отличающихся по размерам от частиц муки. Вы просеиваете через несколько фильтров муку, так как вам не нужны крупные комочки, осколки и другие посторонние частицы, вам нужна именно мука определенного качества. И в зависимости от выставленных фильтров вы будете перехватывать разные частицы, комочки и т.д. Эти частицы и есть исключения. И если выставляется мелкий фильтр, то вы словите как крупные частицы, так и мелкие. Точно также и в `Java`, ставя фильтр на `java.lang.RuntimeException` вы ловите не только `java.lang.RuntimeException`, но и всех его наследников! Ведь эти потомки - **тоже** `runtime` ошибки!

В блоке `finally` определяется код, который будет всегда выполнен, независимо от результата выполнения блоков `try/catch`. Этот блок будет выполняться независимо от того, выполнился или нет блок `try` до конца, было ли сгенерировано исключение или нет, и было ли оно обработано в блоке `catch` или нет.

Пример:

```java
public class ExceptionHandling {
    public static void main(String[] args) {
        try {
             // some code
        } catch(FileNotFoundException fnf) {
            // обработчик 1
        } catch(RuntimeException re) {
            // обработчик 2
        } finally {
            System.out.println("Hello from finally block.");
        }
    }
}
```

В примере выше объявлен `try` блок с кодом, который потенциально может сгенерировать исключения, после `try` блока описаны два обработчика исключений, на случай генерации `FileNotFoundException` и на случай генерации любого `RuntimeException`.
Объект исключения доступен по ссылке `exception`.

##### Правила try/catch/finally

* Блок `try` находится перед блоком `catch` или `finally`. При этом должен присутствовать хотя бы один из этих блоков.
* Между `try`, `catch` и `finally` не может быть никаких операторов.
* Один блок `try` может иметь несколько `catch` блоков. В таком случае будет выполняться первый подходящий блок.

    Поэтому сначала должны идти более специальные блоки обработки исключений, а потом уже более общие.

* Блок `finally` будет выполнен всегда, кроме случая, когда `JVM` преждевременно завершит работу или будет сгенерировано исключение непосредственно в самом `finally` блоке.
* Допускается использование вложенных конструкций `try/catch/finally`.

    ```java
    public class ExceptionHandling {
        public static void main(String[] args) {
            try {
                 try {
                    // some code
                } catch(FileNotFoundException fnf) {
                    // обработчик 1
                }
            } catch(RuntimeException re) {
                // обработчик 2
            } finally {
                System.out.println("Hello from finally block.");
            }
        }
    }
    ```
---

**Вопрос**:

Каков результат выполнения примера выше, если в блоке `try` не будет сгенерировано ни одного исключения?

**Ответ**:

Будет выведено на экран: "Hello from finally block.".

Так как блок `finally` выполняется **всегда**.

---

**Вопрос**:

Теперь немного видоизменим код, каков результат выполнения будет теперь?

```java
public class ExceptionHandling {
  public static void main(String[] args) {
    try {
         return;
    } finally {
         System.out.println("Hello from finally block");
    }
  }
}
```

**Ответ**:

На экран будет выведено: `Hello from finally block`.

---

**Вопрос**:

Плохим тоном считается прямое наследование от `java.lang.Throwable`.
Это **строго** не рекомендуется делать, почему?

**Ответ**:

Наследование от наиболее общего класса, а в данном случае от корневого класса иерархии, усложняет обработку ваших исключений. Проблему надо стараться локализовать, а не делать ее описание/объявление максимально общим. Согласитесь, что `java.lang.IllegalArgumentException` говорит гораздо больше, чем `java.lang.RuntimeException`. А значит и реакция на первое исключение будет более точная, чем на второе.

---

Далее приводится несколько примеров перехвата исключений разных видов:

Обработка `java.lang.RuntimeException`:

```java
try {
   String numberAsString = "one";
   Double res = Double.valueOf(numberAsString);
    } catch (RuntimeException re) {
            System.err.println("Error while convert string to double!");
    }
```

Результатом будет печать на экран: `Error while convert string to double!`.

Обработка `java.lang.Error`:

```java
try {
    throw new Error();
} catch (RuntimeException re) {
    System.out.println("RuntimeException");
} catch (Error error) {
    System.out.println("ERROR");
}
```

Результатом будет печать на экран: `ERROR`.

##### Расположение catch блоков

Как уже было сказано, один блок `try` может иметь несколько `catch` блоков. В таком случае будет выполняться первый подходящий блок.
Это значит, что порядок расположения `catch` блоков важен.

Рассмотрим ситуацию, когда некоторый используемый нами метод может выбросить два разных исключения:

```java
void method() throws Exception {
    if (new Random((System.currentTimeMillis())).nextBoolean()) {
        throw new Exception();
    } else {
       throw new IOException();
    }
}
```

> Конструкция `new Random((System.currentTimeMillis())).nextBoolean()` генерирует нам случайное значение `false` или `true`.

Для обработки исключений этого метода написан следующий код:

```java
try {
  method();
} catch (Exception e) {
  // do some logic 1
} catch (IOException e) {
  // do some logic 2
}
```

И на первый взгляд все хорошо, однако обработка `java.lang.IOException` в данном случае недостижима.

Снова вспомним пример с мукой, приведенный в начале.
При добыче золота, грунт смешивали с водой и прогоняли через несколько фильтров, какие-то были более узкие, какие-то более широкие.

Так вот золотинка, которую мы ищем, это и есть наше исключение, а каждый фильтр это `catch` блок.

Если первым установлен фильтр `ловить все, что является Exception и его потомков`, то до фильтра `ловить все, что является IOException и его потомков` ничего не дойдет, так как верхний фильтр уже перехватит все золотинки.

Отсюда следует правило:

> Сначала должны идти более специальные блоки обработки исключений, а потом уже более общие.

А что если на два разных исключения предусмотрена одна и та же реакция? Написание двух одинаковых `catch` блоков не приветствуется, ведь дублирование кода - это зло.
Поэтому допускается объединить два `catch` блока с помощью `|`:

```java
try {
    method2();
} catch (IllegalArgumentException | IndexOutOfBoundsException e) {
    // do smth
}
```

---

**Вопрос**:

Есть ли способ перехватить **все** возможные исключения?

**Ответ**:

Есть! Если взглянуть еще раз на иерархию, то можно отметить, что `java.lang.Throwable` является родительским классом для всех исключений, а значит, чтобы поймать все, необходимо написать что-то в виде:

```java
try {
  method();
} catch (Throwable t) {
  // catch all
}
```

Однако, делать так **не рекомендуется**, что наталкиевает на следующий вопрос.

---

**Вопрос**:

Почему перехватывать `java.lang.Throwable` плохо?

**Ответ**:

Дело в том, что написав:

```java
try {
  method();
} catch (Throwable t) {
  // catch all
}
```

Будут перехвачены абсолютно все исключения: и `java.lang.Exception`, и `java.lang.RuntimeException`, и `java.lang.Error`, и все их потомки.

И как реагировать на **все**? При этом надо учесть, что обычно на `java.lang.Error` исключений вообще не ясно как реагировать. А значит, мы можем неверно отреагировать на исключение и вообще потерять данные. А ловить то, что не можешь и не собирался обрабатывать - плохо.

Поэтому перехватывать все исключения - плохая практика.

---

**Вопрос-Тест**:

Что будет выведено на экран при запуске данного куска кода?

```java
public static void main(String[] args) {
        try {
            try {
                throw new Exception("0");
            } finally {
                if (true) {
                    throw new IOException("1");
                }

                System.err.println("2");
            }
        } catch (IOException ex) {
            System.err.println(ex.getMessage());
        } catch (Exception ex) {
            System.err.println("3");
            System.err.println(ex.getMessage());
        }
    }
```

**Ответ**:

При выполнении данного кода выведется "1".
Давайте разберем почему.

Мы кидаем исключение во вложенном `try` блоке: `throw new Exception("0");`.

После этого поток программы ломается и мы попадаем в `finally` блок:

```java
if (true) {
    throw new IOException("1");
}

System.err.println("2");
```

Здесь мы гарантированно зайдем в `if` и кинем уже новое исключение: `throw new IOException("1");`.
При этом вся информация о первом исключении будет потеряна! Ведь мы никак не отреагировали на него, а в `finally` блоке и вовсе 'перезатерли' новым исключением.

На `try`, оборачивающий наш код, настроено два фильтра: первый на `IOException`, второй на `Exception`.

Так как порядок расположения задан так, что мы прежде всего смотрим на `IOException`, то и сработает этот фильтр, который выполнит следующий код:

```java
System.err.println(ex.getMessage());
```

Именно поэтому выведется `1`.

---

##### Транзакционность

Важным моментом, который нельзя пропустить, является то, что `try` блок **не транзакционный**.

> Под термином `транзакционность` я имею в виду то, что либо действия будут выполнены целиком и успешно, либо не будут выполнены вовсе.

Что это значит?
Это значит, что при возникновении исключения в `try` блоке все совершенные действия **не** откатываются к изначальному состоянию, а так и остаются совершенными.
Все выделенные ресурсы так и остаются занятыми, в том числе и при возникновении исключения.

По сути именно поэтому и существует `finally`-блок, так как туда, как уже было сказано выше, мы зайдем **в любом** случае, то там и освобождают выделенные ресурсы.

---

**Вопрос**:

Работа с объектами из `try` блока в других блоках невозможна:

```java
public class ExceptionExample {
    public static void main(String[] args) {
        try {
            String line = "hello";
        } catch (Exception e) {
            System.err.println(e);
        }

        // Compile error
        System.out.println(line); // Cannot resolve symbol `line`
    }
}
```

Почему?

**Ответ**:

Потому что компилятор не может нам гарантировать, что объекты, объявленные в `try`-блоке, были созданы.

Ведь могло быть сгенерировано исключение. Тогда после места, где было сгенерировано исключение, оставшиеся действия не будут выполнены, а значит возможна ситуация, когда объект не будет создан. Следовательно и работать с ним нельзя.

---

Вернемся к примеру с грузовиком, чтобы объяснить все вышесказанное.

![Объездная](../images/exception/exception_ob.png)

Объездная здесь - это `catch` блок, реакция на исключительную ситуацию. Если добавить еще несколько объездных дорог, несколько `catch` блоков, то водитель выберет наиболее подходящий путь, наиболее подходящий и удобный `catch` блок, что объясняет важность расположения этих блоков. Транзакционность на этом примере объясняется тем, что если до этого водитель где-то оплатил проезд по мосту, то деньги ему автоматически не вернутся, необходимо будет написать в поддержку или куда-то пожаловаться на управляющую компанию.

#### Делегирование

Выше было разобрано то, как обрабатывать исключения. Однако, иногда возникают ситуации, когда в нет конкретного понимания того, как обрабатывать возникшее исключение. В таком случае имеет смысл делегировать задачу обработки исключения коду, который вызвал ваш метод, так как вызывающий код чаще всего обладает более обширными сведениями об источнике проблемы или об операции, которая сейчас выполняется.

Делегирование исключения производится с помощью ключевого слова `throws`, которое добавляется после сигнатуры метода.

Пример:

```java
// Код написан только для ознакомительной цели, не стоит с него брать пример!
String readLine(String path) throws IOException {
    BufferedReader br = new BufferedReader(...);
    String line = br.readLine();

    return line;
}
```

Таким образом обеспечивается передача объявленного исключения в место вызова метода. И то, **как** на него реагировать уже становится заботой вызывающего этот метод.
Поэтому реагировать и писать обработчики на те исключения, которые мы делегировали, внутри метода уже не надо.

Механизм `throws` введен для проброса проверяемых исключений.

Разумеется, с помощью `throws` можно описывать делегирование как проверяемых, так и непроверяемых исключений.
Однако перечислять непроверяемые не стоит, такие исключения не контролируются в `compile time`. Перечисление непроверяемых исключений бессмысленно, так как это примерно то же самое, что перечислять все, что может с вами случиться на улице.

Теперь пришла пора рассмотреть методы обработки исключительных ситуаций.

#### Методы и практики обработки исключительных ситуаций

Главное и основное правило при работе с исключениями звучит так:

> На исключения надо либо **реагировать**, либо **делегировать**, но ни в коем случае не **игнорировать**.

Определить когда надо реагировать, а когда делегировать проще простого. Задайте вопрос: "Знаю ли я как реагировать на это исключение?".
Если ответ "да, знаю", то реагируйте, пишите обработчик и код, отвечающий за эту реакцию, если не знаете что делать с исключением, то **делегируйте** вызывающему коду.

##### Собственные исключения

Выше мы уже затронули то, что исключения это те же классы и объекты.
И иногда удобно выстроить свою иерархию исключений, заточенных под конкретную задачу. Дабы более гибко обрабатывать и реагировать на те исключительные ситуации, которые специфичны решаемой задаче.

Например, пусть есть некоторый справочник:

```java
class Catalog {
    Person findPerson(String name);
}
```

В данном случае нам надо обработать ситуации, когда `name` является `null`, когда в каталоге нет пользователя с таким именем.

Если генерировать на все ситуации `java.lang.Exception`, то обработка ошибок будет крайне неудобной.
Более того, хотелось бы явно выделить ошибку, связанную с тем, что пользователя такого не существует.
Очевидно, что стандартное исключение для этого случая не существует, а значит вполне логично создать свое.

```java
class PersonNotFoundException extends RuntimeException {
    private String name;

    // some code
}
```

Обратите внимание, что имя `Person`, по которому в каталоге не смогли его найти, выделено в свойство класса `name`.

Теперь при использовании этого метода проще реагировать на различные ситуации, такие как `null` вместо имени, а проблему с отсутствием `Person` в каталоге можно отдельно вынести в свой `catch` блок.

##### Реагирование через re-throw

Часто бывает необходимо перехватить исключение, сделать запись о том, что случилось (в файл лога, например) и делегировать его вызывающему коду.
Как уже было сказано выше, в рамках конструкции `try/catch/finally` возможно повторно сгенерировать исключение.

Такой подход называется `re-throw`.

Исключение перехватывается в `catch` блоке, совершаются необходимые действия, например, запись в лог или создание нового, более конкретного для контекста задачи, исключения и повторная генерация исключения.

Как это выглядит на практике:

```java
try {
    Reader readerConf = ....
    readerConf.readConfig();
} catch(IOException ex) {
    System.err.println("Log exception: " + ex);
    throw new ConfigException(ex);
}
```

Во время чтения конфигурационного файла произошло исключение `java.lang.IOException`, в `catch` блоке оно было перехвачено, сделана запись в консоль о проблеме, после чего было создано новое, более конкретное, исключение `ConfigException`, с указанием причины (перехваченное исключение, ссылка на которое `ex`) и оно было проброшено дальше.

По итогу, из метода с приведенным кодом, в случае ошибки чтения конфигурации, будет выброшено `ConfigException`.

Для чего мы здесь так поступили?

Это полезно для более гибкой обработки исключений.
В примере выше чтение конфигурации генерирует слишком общее исключение, так как `java.lang.IOException` это довольно общее исключение, но проблема в примере выше понятна: работа с этим конфигурационным файлом невозможна.

Значит и сообщить лучше именно как о том, что это не абстрактный `java.lang.IOException`, а именно `ConfigException`. При этом, так как перехваченное исключение было передано новому в конструкторе, т.е указалась причина возникновения `ConfigException`, то при выводе на консоль или обработке в вызывающем коде будет понятно почему `ConfigException` был создан.
Также, можно было добавить еще и текстовое описание к сгенерированному `ConfigException`, более подробно описывающее произошедшую ситуацию.

Еще одной важной областью применения `re-throw` бывает преобразование проверяемых исключений в непроверяемые.
В `Java 8` даже добавили исключение `java.io.UncheckedIOException`, которое предназначено как раз для того, чтобы сделать `java.lang.IOException` непроверяемым, обернуть в `unchecked` обертку.

Пример:

```java
try {
    Reader readerConf = ....
    readerConf.readConfig();
} catch(IOException ex) {
    System.err.println("Log exception: " + ex);
    throw new UncheckedIOException(ex);
}
```

##### Сохранение исключения

Исключения необязательно генерировать, пробрасывать и так далее.
Выше уже упоминалось, что исключение - это `Java`-объект. А значит, его вполне можно присвоить переменной или свойству класса, передать по ссылке в метод и т.д.

```java
class Reader {
    // A holder of the last IOException encountered
    private IOException lastException;

    // some code

    public void read() {
        try {
            Reader readerConf = ....
            readerConf.readConfig();
        } catch(IOException ex) {
            System.err.println("Log exception: " + ex);
            lastException = ex;
        }
    }
}
```

Генерация исключения это довольно дорогостоящая операция. Кроме того, исключения ломают поток выполнения программы. Чтобы не ломать поток выполнения, но при этом иметь возможность в дальнейшем отреагировать на исключительную ситуацию можно присвоить ее свойству класса или переменой.

Подобный прием использован в `java.util.Scanner`, где генерируемое исключение чтения потока сохраняется в свойство класса `lastException`.

Еще одним способом применения сохранения исключения может являться ситуация, когда надо сделать N операций, какие-то из них могут быть не выполнены, но реагировать на это будут позже.
Например, идет запись в базу данных тысячу строк построчно. Из них 100 записей происходит с ошибкой. Эти исключения складываются в список, а после этот список передается специальному методу, который по каждой ситуации из списка как-то отреагирует. Т.е пока делаете операцию, копите ошибки, а потом уже реагируете. Это похоже на то, как опрашивают 1000 человек, а негативные отзывы/голоса записывают, после чего реагируют на них. Согласитесь, было бы глупо после каждого негативного отзыва реагировать, а потом снова возвращаться к толпе.

```java
class Example {
    private List<Exception> exceptions;

    // some code

    public void parse(String s) {
        try {
            // do smth
        } catch(Exception ex) {
            exceptions.add(ex);
        }
    }

    private void handleExceptions()  {
        for(Exception e : exceptions) {
            System.err.println("Log exception: " + e);
        }
    }
}
```

##### Чего нельзя делать при обработке исключений

* Старайтесь не игнорировать исключения.

  В частности, никогда не пишите подобный код:

    ```java
    try {
        Reader readerConf = ....
        readerConf.readConfig();
    } catch(IOException e) {
        e.printStackTrace();
    }
    ```

* Не следует писать 'универсальные' блоки обработки исключений, ведь очень трудно представить себе метод, который одинаково реагировал бы на все возникающие проблемы.

  Также программный код может измениться, а 'универсальный' обработчик исключений будет продолжать обрабатывать новые типы исключений одинаково. Поэтому таких ситуаций лучше не допускать.
* Старайтесь не преобразовывать более конкретные исключения в более общие. В частности, например, не следует `java.lang.IOException` преобразовывать в `java.lang.Exception` или в `java.lang.Throwable`.
  Чем с более конкретными исключениями идет работа, тем проще реагировать и принимать решения об их обработке.
* Старайтесь не злоупотреблять исключениями. Если исключение можно недопустить, например, дополнительной проверкой, то лучше так и сделать.

  Например, можно обезопасить себя от `java.lang.NullPointerException` простой проверкой:

  ```java
  if(ref != null) {
      // some code
  }
  ```

#### Try-with-resources или try-с-ресурсами

Как уже говорилось выше про `finally` блок, код в нем выполняется в любом случае, что делает его отличным кандидатом на место по освобождению ресурсов, учитывая нетранзакционность блока `try`.

Чаще всего за закрытие ресурса будет отвечать код, наподобие этого:

```java
try {
    // code
} finally {
    resource.close();
}
```

Освобождение ресурса(например, освобождение файлового дескриптора) это поведение.

> А за поведение у нас отвечают [интерфейсы](../oop/interface.md).

Это наталкивает на мысль, что нужен некоторый общий интерфейс, который бы реализовывали все классы, для которых необхожимо выполнить какой-то код по освобождению ресурсов, т.е выполнить 'закрытие' в `finally` блоке и еще удобнее, если бы этот однообразный `finally` блок не нужно было писать каждый раз.
Поэтому, начиная с `Java 7`, была введена конструкция `try-with-resources` или `TWR`.

Для этого объявили специальный интерфейс `java.lang.AutoCloseable`, у которого один метод:

```java
void close() throws Exception;
```

Все классы, которые будут использоваться так, как было описано выше, должны реализовать или `java.lang.Closable`, или `java.lang.AutoCloseable`.

В качестве примера, напишем код чтения содержимого файла и представим две реализации этой задачи: используя и не используя `try-with-resources`.

Без использования `try-with-resources`(пример ниже плох и служит только для демонстрации объема необходимого кода):

```java
BufferedReader br = null;
try {
       br = new BufferedReader(new FileReader(path));
       // read from file
   } catch (IOException e) {
       // catch and do smth
   } finally {
           try {
                  if (br != null) {
                     br.close();
                  }
               } catch (IOException ex) {
                     // catch and do smth
               }
   }
```

А теперь то же самое, но в `Java 7+`:

```java
try (FileReader fr = new FileReader(path);
    BufferedReader br = new BufferedReader(fr)) {
         // read from file
} catch (IOException e) {
         // catch and do smth
}
```

По возможности пользуйтесь **только** `try-with-resources`.

> Помните, что без реализации `java.lang.Closable` или `java.lang.AutoCloseable` ваш класс не будет работать с `try-with-resources` так, как показано выше.

---

**Вопрос**:

Получается, что используя `TWR` мы не пишем код для закрытия ресурсов, но при их закрытии может же тоже быть исключение! Что произойдет?

**Ответ**:

Точно также, как и без `TWR`, исключение выбросится так, будто оно было в `finally`-блоке.

Помните, что `TWR`, грубо говоря, просто добавляет вам блок кода вида:

```java
finally {
    resource.close();
}
```

---

#### Общие советы

Как уже было сказано выше, исключения ломают поток выполнения программы. Если же на сгенерированное исключение не найдется обработчика, не будет подходящего `catch` блока, то программа и вовсе будет завершена. Кроме того, генерация исключения это довольно дорогостоящая операция.

Помните, что если исключение можно недопустить, то лучше так и сделать.

Отсюда следует первый совет: не брезгуйте дополнительными проверками.

Поэтому вводите дополнительные проверки на данные, дабы избежать непроверяемые исключения.
Например, запретите вводить в поле возраста не числовые значения, проверяйте ссылки на `null` перед обращением и т.д.

При написании `API` к каким-то хранилищам или коллекциям очень часто на отсутствие элемента генерируется исключение, как например в разделе [собственные исключения](#Собственные-исключения).

```java
class Catalog {
    Person findPerson(String name);
}
```

Но и в этом случае генерации исключения можно избежать, если воспользоваться `java.util.Optional`:

```java
Optional<Person> findPerson(String name);
```

Класс `java.util.Optional` был добавлен в `Java 8` и предназначен как раз для подобных ситуаций, когда возвращаемого значения может не быть. В зависимости от задачи и контекста можно как генерировать исключение, как это сделано в примере с `PersonNotFoundException`, так и изменить сигнатуру метода, воспользовавшись `java.util.Optional`.

Отсюда следует второй совет: думайте над `API` ваших классов, исключений можно избежать воспользовавшись другим подходом.

Важным моментом, который нельзя не упомянуть, является то, что если в методе объявляется, что он может сгенерировать исключение (с помощью `throws`), то при переопределении такого метода нельзя указать более общее исключение в качестве выбрасываемого.

```java
class Person {
    void hello() throws RuntimeException {
        // some code
    }
}

// Compile Error
class PPerson extends Person {
    @Override
    void hello() throws Exception {
        // some code
    }
}
```

Если было явно указано, что метод может сгенерировать `java.lang.RuntimeException`, то нельзя объявить более общее бросаемое исключение при переопредлении. Но можно указать потомка:

```java
// IllegalArgumentException - потомок RuntimeException!
class PPerson extends Person {
    @Override
    void hello() throws IllegalArgumentException {
        // some code
    }
}
```

Что, в целом логично. Если объявляется, что метод может сгенерировать `java.lang.RuntimeException`, а он выбрасывает `java.lang.IOException`, то это было бы как минимум странно. Это объясняется и с помощью полимофризма. Пусть есть интерфейс, в котором объявлен метод, генерирующий исключение. Если полиморфно работать с объектом через общий интерфейс, то разработчик обязан обработать исключение, объявленное в интерфейсе, а если одна из реализаций интерфейса генерирует более общее исключение, то это нарушает полиморфизм. Поэтому такой код даже не скомпилируется. При этом при переопределении можно вообще не объявлять бросаемые исключения, таким образом сообщив, что все проблемы будут решены в методе:

```java
class PPerson extends Person {
    @Override
    void hello() {
        // some code
    }
}
```

Отсюда следует третий совет: необходимо думать о тех исключениях, которые делегирует метод, если класс может участвовать в наследовании.

### Исключения и статические блоки

Еще интересно поговорить про то, что происходит, если исключение возникает в статическом блоке.

Так вот, такие исключения оборачиваются в `java.lang.ExceptionInInitializerError`:

```java
public class ExceptionHandling {
    static {
        throwRuntimeException();
    }

    private static void throwRuntimeException()  {
        throw new NullPointerException();
    }

    public static void main(String[] args)  {
        System.out.println("Hello World");
    }
}
```

Результатом будет падение со следующим стектрейсом:

```java
java.lang.ExceptionInInitializerError Caused by: java.lang.NullPointerException at exception.test.ExceptionHandling.throwRuntimeException(ExceptionHandling.java:13) at exception.test.ExceptionHandling. (ExceptionHandling.java:8)
```

### Многопоточность и исключения

Код в `Java` потоке выполняется в методе со следующей сигнатурой:

```java
public void run();
```

Что делает невозможным пробрасывание проверяемых исключений, т.е разработчик **должен** обрабатывать все проверяемые исключения внутри метода `run`.

Непроверяемые исключения обрабатывать необязательно, однако необработанное исключение, выброшенное из `run`, завершит работу потока.

Например:

```java
public class ExceptionHandling4 {
  public static void main(String[] args) throws InterruptedException {
    Thread t = new Thread() {
        @Override
        public void run() {
                throw new RuntimeException("Testing unhandled exception processing.");
         }
    };
    t.start();
  }
}
```

Результатом выполнения этого кода будет то, что возникшее исключение прервет поток исполнения (interrupt thread):

```java
Exception in thread “Thread-0” java.lang.RuntimeException: Testing unhandled exception processing. at exception.test. ExceptionHandling4$1.run(ExceptionHandling4.java:27)
```

При использовании нескольких потоков бывают ситуации, когда надо знать, как поток завершился, из-за какого именно исключения. И, разумеется, отреагировать на это.
В таких ситуациях рекомендуется использовать `Thread.UncaughtExceptionHandler`.

```java
t.setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {
          public void uncaughtException(Thread t, Throwable e)   {
             System.out.println("Handled uncaught exception in thread :" + t + " Exception : " + e);
         }
  });
```

И вывод уже будет:

```java
Handled uncaught exception in thread :Thread[Thread-0,5,main] Exception : java.lang.RuntimeException: Testing unhandled exception processing.
```

Необработанное исключение `RuntimeException("Testing unhandled exception processing.")`, убившее поток, было перехвачено специальным зарегистрированным обработчиком.

### Проверяемые исключения и их необходимость

В большинстве языков программирования, таких как `C#`, `Scala`, `Groovy`, `Python` и т.д., нет такого разделения, как в `Java`, на проверяемые и непроверяемые исключения.
Почему оно введено в `Java` было разобрано выше, а вот почему проверяемые исключения недолюбливают разработчики?

Основных причин две, это причины с: версионированием и масштабируемостью.

Представим, что вы, как разработчик библиотеки, объявили некоторый условный метод `foo`, бросающий исключения `A`, `B` и `C`:

```java
void foo() throws A, B, C;
```

В следующей версии библиотеки в метод `foo` добавили функциональности и теперь он бросает еще новое исключение `D`:

```java
void foo() throws A, B, C, D;
```

В таком случае новая версия библиотеки сломает код тех, кто ей пользуется. Это сравнимо с тем, что добавляется новый метод в интерфейс.

И с одной стороны, это правильно, так как в новой версии добавляется еще одно исключение и те, кто использует библиотеку должны отреагировать на все новые исключения. С другой стороны, чаще всего такие исключения будут также проброшены дальше. Все дело в том, что случаев, когда можно обработать специфический тип исключения, например тот же `D` или `A` в примере выше, и сделать в обработчике что-то интеллектуальное, можно пересчитать по пальцам одной руки.

Проблема с масштабируемостью начинается тогда, когда происходит вызов не одного, а нескольких `API`, каждый из которых также несет с собой проверяемые исключения. Представьте, что помимо `foo`, бросающего `A`, `B`, `C` и `D`, в методе `hello` вызывается еще и `bar`, который также бросает `E` и `T` исключения. Как сказано выше, как реагировать чаще всего непонятно, поэтому эти исключения делегируются вызывающему коду, из-за чего объявление метода `hello` выглядит совсем уж угрожающе:

```java
void hello() throws A, B, C, D, E, T {
    try {
        foo();
        bar();
    } finally {
        // clear resources if needed
    }
}
```

Все это настолько раздражающе, что чаще всего разработчики просто объявляют наиболее общее исключение в `throws`:

```java
void hello() throws Exception {
    try {
        foo();
        bar();
    } finally {
        // clear resources if needed
    }
}
```

А в таком случае это все равно, что сказать "метод может выбросить исключение" - это настолько общие и абстрактные слова, что смысла в `throws Exception` не много.

Также есть еще одна проблема с проверяемыми исключениями. Это то, что с проверямыми исключениями крайне неудобно работать в `lambda`-ах и `stream`-ах:

```java
// compilation error
    Lists.newArrayList("a", "asg").stream().map(e -> {throw new Exception();});
```

Так как с `Java 8` использование `lambda` и `stream`-ов распространенная практика, то накладываемые ограничения вызовут дополнительные трудности при использовании проверяемых исключений.

Поэтому многие разработчики недолюбливают проверяемые исключения, например, оборачивая их в непроверяемые аналоги с помощью `re-throw`.

Мое мнение таково: на проверямых исключениях очень хорошо учиться. Компилятор и язык сами подсказывают вам, что нельзя игнорировать исключения и требуют от вас реакции. Опять же, логическое раздление на проверяемые и непроверяемые помогает в понимании исключений, в понимании того как и на что реагировать. В промышленной же разработке это становится уже больше раздражающим фактором.

В своей работе я стараюсь чаще использовать непроверяемые исключения, а проверяемые оборачивать в `unchecked` аналоги, как, например, `java.io.IOException` и `java.io.UncheckedIOException`.

### Заключение

Иерархия исключений в `Java`.

![Exception Hierarchy](../images/exception/exceptions.png)

Исключения делятся на два типа: непроверяемые(`unchecked`) и проверяемые(`checked`). Проверяемые исключения - это исключения, которые проверяются на этапе компиляции, мы **обязаны** на них отреагировать.

Проверяемые исключения в `Java` используются тогда, когда разработчик никак не может предотвратить их возникновение. Причину возникновения `java.lang.RuntimeException` можно проверить и устранить заранее, например, проверить ссылку на `null` перед вызовом метода, на объекте по ссылке. А вот с причинами проверяемых исключений так сделать не получится, так как ошибка при чтении файла может возникнуть непосредственно в момент чтения, потому что другая программа его удалила. Соответственно, при чтении файла требуется обрабатывать `java.lang.IOException`, который является потомком `java.lang.Exception`.

Допускается создание собственных исключений, признак проверяемости или непроверяемости наследуется от родителя. Исключения - это такие же классы, со своим поведением и состоянием, поэтому при наследовании вполне допускается добавить дополнительное поведение или свойства классу.

Обработка исключений происходит с помощью конструкции `try/catch/finally`. Один блок `try` может иметь несколько `catch` блоков. В таком случае будет выполняться первый подходящий блок.

Помните, что `try` блок **не транзакционен**, все ресурсы, занятые в `try` **ДО** исключения остаются в памяти. Их надо освобождать и очищать вручную.
Если вы используете `Java` версии 7 и выше, то отдавайте предпочтение конструкции `try-with-resources`.

Основное правило:

> На исключения можно реагировать, их обработку можно делегировать, но ни в коем случае нельзя их игнорировать.

Определить когда надо реагировать, а когда делегировать проще простого. Задайте вопрос: "Знаю ли я как реагировать на это исключение?".
Если ответ "да, знаю", то реагируйте, пишите обработчик и код, отвечающий за эту реакцию, если не знаете что делать с исключением, то **делегируйте** вызывающему коду.

Помните, что перехват `java.lang.Error` стоит делать только если вы точно знаете, что делаете. Восстановление после таких ошибок не всегда возможно и почти всегда нетривиально.
Не забывайте, что большинство ошибок `java.lang.RuntimeException` и его потомков можно избежать.

Не бойтесь создавать собственные исключения, так как это позволит писать более гибкие обработчики, а значит более точно реагировать на проблемы.

> Представьте себе, что существуют пять причин, по которым может быть выброшено исключение, и во всех пяти случаях бросается `java.lang.Exception`. Вы же спятите разбираться, чем именно это исключение вызвано.
>
> (c) Евгений Матюшкин.

Помните, что исключения ломают поток выполнения программы, поэтому чем раньше вы обработаете возникшую проблему, тем лучше. Отсюда же следует совет, что лучше не разбрасываться исключениями, так как помимо того, что это ломает поток выполнения, это еще и дорогостоящая операция.

Постарайтесь не создавать 'универсальных' обработчиков, так как это чревато трудноуловимыми ошибками.

Если исключение можно не генерировать, то лучше так и сделать. Не пренебрегайте проверками.

Старайтесь продумывать то, как вы будете реагировать на исключения, не игнорировать их, использовать **только** `try-с-ресурсами`.

Помните:

> In Java you can ignore exceptions, but you have to willfully do it. You can't accidentally say, "I don't care." You have to explicitly say, "I don't care."
>
> (c) James Gosling.

### Полезные ссылки

1. [Книга С. Стелтинг 'Java без сбоев: обработка исключений, тестирование, отладка'](https://www.ozon.ru/context/detail/id/2342758/)
2. [Oracle Java Tutorials](https://docs.oracle.com/javase/tutorial/essential/exceptions/index.html)
3. [Лекция Технострим Исключения](https://www.youtube.com/watch?v=zRRopPImRqA)
4. [Лекция OTUS Исключения в Java](https://www.youtube.com/watch?v=nP-yT6tmbGs)
5. [Лекция Ивана Пономарёва по исключениям](https://www.youtube.com/watch?v=YgY2pksf3k8&list=PL4_hYwCyhAvblhTbPQmOF4b3kilWSpOjU&index=4)
6. [Заметка Евгения Матюшкина про Исключения](http://www.skipy.ru/technics/exceptions.html)
7. [Failure and Exceptions by James Gosling](https://www.artima.com/intv/solid.html)
8. [The Trouble with Checked Exceptions by Bill Venners with Bruce Eckel](https://www.artima.com/intv/handcuffs.html)
9. [Никто не умеет обрабатывать ошибки](https://habr.com/ru/post/221723/)

<p class="source">Данный материал основан на главе из книги <a href="https://github.com/qcha/JBook">JBook</a> с разрешения авторов. Подписывайтесь и ставьте звездочки!</p>
